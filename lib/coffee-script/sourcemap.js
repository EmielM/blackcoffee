// Generated by CoffeeScript 1.8.0
(function() {
  var LineMap, SourceMap, helpers;

  helpers = require('./helpers');

  LineMap = (function() {
    function LineMap(line) {
      this.line = line;
      this.columns = [];
    }

    LineMap.prototype.add = function(column, loc, options) {
      if (options == null) {
        options = {};
      }
      if (this.columns[column] && options.noReplace) {
        return;
      }
      return this.columns[column] = loc;
    };

    LineMap.prototype.sourceLocation = function(column) {
      var loc;
      while (!((loc = this.columns[column]) || (column <= 0))) {
        column--;
      }
      return loc;
    };

    return LineMap;

  })();

  SourceMap = (function() {
    var BASE64_CHARS, VLQ_CONTINUATION_BIT, VLQ_SHIFT, VLQ_VALUE_MASK;

    function SourceMap(fragments, options) {
      var code, currentColumn, currentLine, fragment, lineMap, loc, newLines, pos, _base, _i, _len;
      if (options == null) {
        options = {};
      }
      this.lines = [];
      if (!fragments) {
        return;
      }
      currentLine = 0;
      if (options.header) {
        currentLine += 1;
      }
      if (options.shiftLine) {
        currentLine += 1;
      }
      currentColumn = 0;
      for (_i = 0, _len = fragments.length; _i < _len; _i++) {
        fragment = fragments[_i];
        if (loc = fragment.locationData) {
          lineMap = ((_base = this.lines)[currentLine] || (_base[currentLine] = new LineMap(currentLine)));
          lineMap.add(currentColumn, loc, options);
        }
        code = fragment.code;
        newLines = pos = 0;
        while (pos = 1 + code.indexOf("\n", pos)) {
          newLines++;
        }
        if (newLines) {
          currentLine += newLines;
          currentColumn = code.length - (code.lastIndexOf("\n") + 1);
        } else {
          currentColumn += code.length;
        }
      }
    }

    SourceMap.prototype.sourceLocation = function(line, column) {
      var lineMap;
      while (!((lineMap = this.lines[line]) || (line <= 0))) {
        line--;
      }
      return lineMap && lineMap.sourceLocation(column);
    };

    SourceMap.prototype.generate = function(options) {
      var buffer, dstColumn, dstLine, lastColumn, lastSourceColumn, lastSourceIndex, lastSourceLine, lineMap, loc, needComma, v3, writingline, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      writingline = 0;
      lastColumn = 0;
      lastSourceIndex = 0;
      lastSourceLine = 0;
      lastSourceColumn = 0;
      needComma = false;
      buffer = "";
      _ref = this.lines;
      for (dstLine = _i = 0, _len = _ref.length; _i < _len; dstLine = ++_i) {
        lineMap = _ref[dstLine];
        if (lineMap) {
          _ref1 = lineMap.columns;
          for (dstColumn = _j = 0, _len1 = _ref1.length; _j < _len1; dstColumn = ++_j) {
            loc = _ref1[dstColumn];
            if (!(loc)) {
              continue;
            }
            while (writingline < dstLine) {
              lastColumn = 0;
              needComma = false;
              buffer += ";";
              writingline++;
            }
            if (needComma) {
              buffer += ",";
              needComma = false;
            }
            buffer += this.encodeVlq(dstColumn - lastColumn);
            lastColumn = dstColumn;
            buffer += this.encodeVlq(loc.file_num - lastSourceIndex);
            lastSourceIndex = loc.file_num;
            buffer += this.encodeVlq(loc.first_line - lastSourceLine);
            lastSourceLine = loc.first_line;
            buffer += this.encodeVlq(loc.first_column - lastSourceColumn);
            lastSourceColumn = loc.first_column;
            needComma = true;
          }
        }
      }
      v3 = {
        version: 3,
        file: options.generatedFile || '',
        sourceRoot: options.sourceRoot || '',
        sources: helpers.filenames || [],
        names: [],
        mappings: buffer
      };
      if (options.inline) {
        v3.sourcesContent = helpers.scripts || [];
      }
      return JSON.stringify(v3, null, 2);
    };

    VLQ_SHIFT = 5;

    VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;

    VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;

    SourceMap.prototype.encodeVlq = function(value) {
      var answer, nextChunk, signBit, valueToEncode;
      answer = '';
      signBit = value < 0 ? 1 : 0;
      valueToEncode = (Math.abs(value) << 1) + signBit;
      while (valueToEncode || !answer) {
        nextChunk = valueToEncode & VLQ_VALUE_MASK;
        valueToEncode = valueToEncode >> VLQ_SHIFT;
        if (valueToEncode) {
          nextChunk |= VLQ_CONTINUATION_BIT;
        }
        answer += this.encodeBase64(nextChunk);
      }
      return answer;
    };

    BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    SourceMap.prototype.encodeBase64 = function(value) {
      return BASE64_CHARS[value] || (function() {
        throw new Error("Cannot Base64 encode value: " + value);
      })();
    };

    return SourceMap;

  })();

  module.exports = SourceMap;

}).call(this);
